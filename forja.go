package forja

import (
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"reflect"
	"runtime"
	"strings"

	"github.com/labstack/echo/v4"
	orderedmap "github.com/wk8/go-ordered-map/v2"
)

type Handler[P any, R any] func(c echo.Context, params P) (R, error)

type Router interface {
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// Forja is the main struct that handles type information for every given handler.
// To add handlers to it use
type Forja struct {
	router         Router
	handlers       *orderedmap.OrderedMap[string, reflect.Type] // "package.handler" -> Handler type
	customTypes    []reflect.Type
	typegen        *typegen
	variables      *orderedmap.OrderedMap[string, any] // Custom variables to export in the TypeScript client
	constVariables *orderedmap.OrderedMap[string, any] // Custom const variables to export with "as const"

	config Config
}

func NewForja(router Router) *Forja {
	return NewForjaWithConfig(router, Config{})
}

type Config struct {
	// OnErr, if not nil will be called if the handler responds with an error
	OnErr func(c echo.Context, err error) error
}

func NewForjaWithConfig(router Router, config Config) *Forja {
	th := &Forja{
		router:         router,
		config:         config,
		handlers:       orderedmap.New[string, reflect.Type](),
		typegen:        newTypegen(),
		variables:      orderedmap.New[string, any](),
		constVariables: orderedmap.New[string, any](),
	}
	return th
}

func cleanHandlerName(handlerName string) string {
	handlerName = strings.ReplaceAll(handlerName, "(", "")
	handlerName = strings.ReplaceAll(handlerName, ")", "")
	handlerName = strings.ReplaceAll(handlerName, "*", "")

	return handlerName
}

func AddHandler[P any, R any](th *Forja, handler Handler[P, R]) {
	handlerFunc := runtime.FuncForPC(reflect.ValueOf(handler).Pointer())
	fullName := handlerFunc.Name()

	// Explanation for this "-fm" thingy
	// https://github.com/golang/go/issues/52809#issuecomment-1122696583
	fullName = strings.TrimSuffix(fullName, "-fm")

	parts := strings.Split(fullName, "/")
	parts = strings.Split(parts[len(parts)-1], ".")

	packageName := parts[0]
	handlerName := strings.Join(parts[1:], "_")

	// if handler is a method of a struct pointer, we need to clean it, as it
	// will come in the form of:
	// (*Mystruct)_methodName
	handlerName = cleanHandlerName(handlerName)

	// Extract just the method name if it's a struct method (contains underscore)
	if strings.Contains(handlerName, "_") {
		handlerName = strings.Split(handlerName, "_")[1]
	}

	path := fmt.Sprintf("/%s.%s", packageName, handlerName)

	th.handlers.Set(path, reflect.TypeOf(handler))

	th.router.POST(path, func(c echo.Context) error {
		var params P
		if err := c.Bind(&params); err != nil {
			return echo.NewHTTPError(400, err.Error())
		}

		result, err := handler(c, params)
		if err != nil {
			if th.config.OnErr != nil {
				err = th.config.OnErr(c, err)
			}

			return c.JSON(400, map[string]string{
				"message": err.Error(),
			})
		}

		return c.JSON(200, result)
	})
}

func (fj *Forja) WriteTsClient(path string) error {
	generated := fj.GenerateTypescriptClient()
	return os.WriteFile(path, []byte(generated), 0644)
}

func (fj *Forja) GenerateTypescriptClient() string {
	output := new(strings.Builder)

	// Generate ApiError type and ApiResponse type
	output.WriteString(`
// AUTOGENERATED, DO NOT EDIT

`)

	// Export custom variables
	if fj.variables != nil && fj.variables.Len() > 0 {
		for pair := fj.variables.Oldest(); pair != nil; pair = pair.Next() {
			name, value := pair.Key, pair.Value
			jsonBytes, err := json.MarshalIndent(value, "", "  ")
			if err != nil {
				// If there's an error, add a comment explaining the issue
				fmt.Fprintf(output, "// Error encoding %s: %s\n", name, err.Error())
				continue
			}
			fmt.Fprintf(output, "export const %s = %s\n\n", name, string(jsonBytes))
		}
	}

	// Export custom const variables with "as const" assertion
	if fj.constVariables != nil && fj.constVariables.Len() > 0 {
		for pair := fj.constVariables.Oldest(); pair != nil; pair = pair.Next() {
			name, value := pair.Key, pair.Value
			jsonBytes, err := json.MarshalIndent(value, "", "  ")
			if err != nil {
				// If there's an error, add a comment explaining the issue
				fmt.Fprintf(output, "// Error encoding %s: %s\n", name, err.Error())
				continue
			}
			fmt.Fprintf(output, "export const %s = %s as const\n\n", name, string(jsonBytes))
		}
	}

	output.WriteString(`export interface ApiError {
  message: string
  statusCode?: number
}
export type ApiResponse<T> =
  | { data: T; error: null }
  | { data: null; error: ApiError }

`)

	type PackageName = string
	type HandlerName = string
	type Handler struct {
		isInputEmpty bool
		handlerType  reflect.Type
	}

	// Handler is a pointer so that we can update isInputEmpty later.
	type Packages orderedmap.OrderedMap[PackageName, orderedmap.OrderedMap[HandlerName, *Handler]]

	packages := orderedmap.New[PackageName, *orderedmap.OrderedMap[HandlerName, *Handler]]()
	for pair := fj.handlers.Oldest(); pair != nil; pair = pair.Next() {
		fullPath, handlerType := pair.Key, pair.Value
		parts := strings.Split(fullPath, ".")
		if len(parts) != 2 {
			continue
		}
		packageName, handlerName := parts[0], parts[1]
		packageParts := strings.Split(packageName, "/")
		simplifiedPackageName := packageParts[len(packageParts)-1]
		packageMap, exists := packages.Get(simplifiedPackageName)
		if !exists {
			packageMap = orderedmap.New[HandlerName, *Handler]()
			packages.Set(simplifiedPackageName, packageMap)
		}
		packageMap.Set(handlerName, &Handler{
			isInputEmpty: false,
			handlerType:  handlerType,
		})
	}

	type HandlerTsType = string
	apiClientTsDefinitions := orderedmap.New[PackageName, *orderedmap.OrderedMap[HandlerName, HandlerTsType]]()

	for packagePair := packages.Oldest(); packagePair != nil; packagePair = packagePair.Next() {
		packageName, handlers := packagePair.Key, packagePair.Value
		for handlerPair := handlers.Oldest(); handlerPair != nil; handlerPair = handlerPair.Next() {
			handlerName, handler := handlerPair.Key, handlerPair.Value
			_, _, _ = packageName, handlerName, handler.handlerType
			inputType := handler.handlerType.In(1)
			outputType := handler.handlerType.Out(0).Elem()
			inputTypeName := fj.typegen.FillTypeDefinitions(inputType)
			outputTypeName := fj.typegen.FillTypeDefinitions(outputType)

			handlerTsName := camelcaseNames(packageName, handlerName, "Handler")

			isInputEmptyStruct := inputType.Kind() == reflect.Struct && inputType.NumField() == 0
			if isInputEmptyStruct {
				handlerMap, _ := packages.Get(packageName)
				handlerItem, _ := handlerMap.Get(handlerName)
				handlerItem.isInputEmpty = true
				fmt.Fprintf(output,
					"type %s = () => Promise<ApiResponse<%s>>\n",
					handlerTsName, outputTypeName)
			} else {
				fmt.Fprintf(output,
					"type %s = (params: %s) => Promise<ApiResponse<%s>>\n",
					handlerTsName, inputTypeName, outputTypeName)
			}

			packageMap, exists := apiClientTsDefinitions.Get(packageName)
			if !exists {
				packageMap = orderedmap.New[HandlerName, HandlerTsType]()
				apiClientTsDefinitions.Set(packageName, packageMap)
			}

			packageMap.Set(handlerName, handlerTsName)
		}
	}

	fmt.Fprintln(output, "export type ApiClient = {")
	for pair := apiClientTsDefinitions.Oldest(); pair != nil; pair = pair.Next() {
		packageName, packageTypeDef := pair.Key, pair.Value
		fmt.Fprintln(output, "  ", packageName, ": {")
		for handlerPair := packageTypeDef.Oldest(); handlerPair != nil; handlerPair = handlerPair.Next() {
			handlerName, handlerTypeName := handlerPair.Key, handlerPair.Value
			fmt.Fprintln(output, "    ", handlerName, ": ", handlerTypeName, ",")
		}
		fmt.Fprintln(output, "  ", "},")
	}
	fmt.Fprintln(output, "}")

	fj.typegen.printTypeDefs(output)

	// Generate createApiClient function
	output.WriteString(`
export type ApiClientConfig = {
  beforeRequest?: (config: RequestInit) => void | Promise<void>
}

export const REQUEST_ABORTED = 'REQUEST_ABORTED'

export function createApiClient(
  baseUrl: string,
  config?: ApiClientConfig
): ApiClient {
  async function doFetch(path: string, params?: unknown) {
    try {
	  if (params === undefined) {
	  	params = {}
	  }

      const requestConfig: RequestInit = {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(params ?? {}),
      }

      if (config?.beforeRequest) {
        await config.beforeRequest(requestConfig)
      }

      const response = await fetch(` + "`${baseUrl}/${path}`" + `, requestConfig)
      if (!response.ok) {
        const data = await response.json()
        const message = data.message

        return {
          data: null,
          error: { message, statusCode: response.status },
        }
      }
      const data = await response.json()
      return { data, error: null }
    } catch (error) {
      if (error instanceof DOMException && error.name === 'AbortError') {
        return {
          data: null,
          error: {
            message: REQUEST_ABORTED,
          },
        }
      }
      return {
        data: null,
        error: {
          message:
            error instanceof Error ? error.message : 'Unknown error occurred',
        },
      }
    }
  }
  const client: ApiClient = {
`)

	// Generate client methods
	for packagePair := packages.Oldest(); packagePair != nil; packagePair = packagePair.Next() {
		packageName, handlers := packagePair.Key, packagePair.Value
		fmt.Fprintf(output, "    %s: {\n", packageName)
		for handlerPair := handlers.Oldest(); handlerPair != nil; handlerPair = handlerPair.Next() {
			handlerName, handler := handlerPair.Key, handlerPair.Value
			var callback string
			if handler.isInputEmpty {
				callback = fmt.Sprintf(
					"      %s: () => doFetch(\"%s.%s\"),\n",
					handlerName, packageName, handlerName)
			} else {
				callback = fmt.Sprintf(
					"      %s: (params) => doFetch(\"%s.%s\", params),\n",
					handlerName, packageName, handlerName)
			}

			output.WriteString(callback)
		}
		output.WriteString("    },\n")
	}

	output.WriteString(`  }
  return client
}
`)

	for _, typ := range fj.customTypes {
		output.WriteString(fj.typegen.generateTypeDefinition(typ))
	}

	result := output.String()

	return result
}

func (fj *Forja) AddType(typ any) {
	fj.customTypes = append(fj.customTypes, reflect.TypeOf(typ))
}

func WriteToFile(th *Forja, filename string) error {
	generated := []byte(th.GenerateTypescriptClient())
	return os.WriteFile(filename, generated, 0644)
}

func WriteToFileWithCmd(th *Forja, filename string, cmd *exec.Cmd) error {
	if err := WriteToFile(th, filename); err != nil {
		return err
	}

	return cmd.Run()
}

func camelcaseNames(names ...string) string {
	for i, name := range names {
		if len(name) > 0 {
			names[i] = strings.ToUpper(name[:1]) + name[1:]
		}
	}
	return strings.Join(names, "")
}

// Option is a special type that makes it easy to encode optional values and
// enums (see examples). We do not support generics (yet), so this type is handled
// as a separate entity when "compiling" types to typescript.
type Option[T any] struct {
	IsValid bool
	Value   T
}

func (o *Option[T]) Valid() bool {
	if o == nil {
		return false
	}

	return o.IsValid
}

func (o *Option[T]) MarshalJSON() ([]byte, error) {
	if o.IsValid {
		return json.Marshal(o.Value)
	}
	return json.Marshal(nil)
}

func (o *Option[T]) UnmarshalJSON(data []byte) error {
	if string(data) == "null" {
		o.IsValid = false
		return nil
	}
	o.IsValid = true
	return json.Unmarshal(data, &o.Value)
}

// AddVariable adds a custom variable to be exported in the TypeScript client.
// The value will be JSON encoded and exported as a TypeScript variable.
func (fj *Forja) AddVariable(variableName string, value any) {
	// Store the variable name and value
	if fj.variables == nil {
		fj.variables = orderedmap.New[string, any]()
	}
	fj.variables.Set(variableName, value)
}

// AddConstVariable adds a custom variable to be exported in the TypeScript client
// with the "as const" assertion, which preserves literal types in TypeScript.
// This makes the types more precise than regular variables.
func (fj *Forja) AddConstVariable(variableName string, value any) {
	// Store the variable name and value with a flag indicating it should use "as const"
	if fj.constVariables == nil {
		fj.constVariables = orderedmap.New[string, any]()
	}
	fj.constVariables.Set(variableName, value)
}
